// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package repositories

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type InvoiceInvoiceStatus string

const (
	InvoiceInvoiceStatusPENDING   InvoiceInvoiceStatus = "PENDING"
	InvoiceInvoiceStatusPAID      InvoiceInvoiceStatus = "PAID"
	InvoiceInvoiceStatusCANCELLED InvoiceInvoiceStatus = "CANCELLED"
)

func (e *InvoiceInvoiceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoiceInvoiceStatus(s)
	case string:
		*e = InvoiceInvoiceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoiceInvoiceStatus: %T", src)
	}
	return nil
}

type NullInvoiceInvoiceStatus struct {
	InvoiceInvoiceStatus InvoiceInvoiceStatus `json:"invoice_invoice_status"`
	Valid                bool                 `json:"valid"` // Valid is true if InvoiceInvoiceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoiceInvoiceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoiceInvoiceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoiceInvoiceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoiceInvoiceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoiceInvoiceStatus), nil
}

type InvoicePaymentMethod string

const (
	InvoicePaymentMethodCREDITCARD   InvoicePaymentMethod = "CREDIT_CARD"
	InvoicePaymentMethodBANKTRANSFER InvoicePaymentMethod = "BANK_TRANSFER"
	InvoicePaymentMethodPAYPAL       InvoicePaymentMethod = "PAYPAL"
)

func (e *InvoicePaymentMethod) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoicePaymentMethod(s)
	case string:
		*e = InvoicePaymentMethod(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoicePaymentMethod: %T", src)
	}
	return nil
}

type NullInvoicePaymentMethod struct {
	InvoicePaymentMethod InvoicePaymentMethod `json:"invoice_payment_method"`
	Valid                bool                 `json:"valid"` // Valid is true if InvoicePaymentMethod is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoicePaymentMethod) Scan(value interface{}) error {
	if value == nil {
		ns.InvoicePaymentMethod, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoicePaymentMethod.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoicePaymentMethod) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoicePaymentMethod), nil
}

type InvoicePaymentStatus string

const (
	InvoicePaymentStatusPENDING   InvoicePaymentStatus = "PENDING"
	InvoicePaymentStatusCOMPLETED InvoicePaymentStatus = "COMPLETED"
	InvoicePaymentStatusFAILED    InvoicePaymentStatus = "FAILED"
)

func (e *InvoicePaymentStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = InvoicePaymentStatus(s)
	case string:
		*e = InvoicePaymentStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for InvoicePaymentStatus: %T", src)
	}
	return nil
}

type NullInvoicePaymentStatus struct {
	InvoicePaymentStatus InvoicePaymentStatus `json:"invoice_payment_status"`
	Valid                bool                 `json:"valid"` // Valid is true if InvoicePaymentStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullInvoicePaymentStatus) Scan(value interface{}) error {
	if value == nil {
		ns.InvoicePaymentStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.InvoicePaymentStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullInvoicePaymentStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.InvoicePaymentStatus), nil
}

type TicketTicketPriority string

const (
	TicketTicketPriorityLOW      TicketTicketPriority = "LOW"
	TicketTicketPriorityMEDIUM   TicketTicketPriority = "MEDIUM"
	TicketTicketPriorityHIGH     TicketTicketPriority = "HIGH"
	TicketTicketPriorityURGENT   TicketTicketPriority = "URGENT"
	TicketTicketPriorityCRITICAL TicketTicketPriority = "CRITICAL"
)

func (e *TicketTicketPriority) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TicketTicketPriority(s)
	case string:
		*e = TicketTicketPriority(s)
	default:
		return fmt.Errorf("unsupported scan type for TicketTicketPriority: %T", src)
	}
	return nil
}

type NullTicketTicketPriority struct {
	TicketTicketPriority TicketTicketPriority `json:"ticket_ticket_priority"`
	Valid                bool                 `json:"valid"` // Valid is true if TicketTicketPriority is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTicketTicketPriority) Scan(value interface{}) error {
	if value == nil {
		ns.TicketTicketPriority, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TicketTicketPriority.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTicketTicketPriority) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TicketTicketPriority), nil
}

type TicketTicketStatus string

const (
	TicketTicketStatusOPEN       TicketTicketStatus = "OPEN"
	TicketTicketStatusINPROGRESS TicketTicketStatus = "IN_PROGRESS"
	TicketTicketStatusRESOLVED   TicketTicketStatus = "RESOLVED"
	TicketTicketStatusCLOSED     TicketTicketStatus = "CLOSED"
	TicketTicketStatusREOPENED   TicketTicketStatus = "REOPENED"
)

func (e *TicketTicketStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TicketTicketStatus(s)
	case string:
		*e = TicketTicketStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for TicketTicketStatus: %T", src)
	}
	return nil
}

type NullTicketTicketStatus struct {
	TicketTicketStatus TicketTicketStatus `json:"ticket_ticket_status"`
	Valid              bool               `json:"valid"` // Valid is true if TicketTicketStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTicketTicketStatus) Scan(value interface{}) error {
	if value == nil {
		ns.TicketTicketStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TicketTicketStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTicketTicketStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TicketTicketStatus), nil
}

type UserRole string

const (
	UserRoleAdmin      UserRole = "Admin"
	UserRoleTechnician UserRole = "Technician"
)

func (e *UserRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserRole(s)
	case string:
		*e = UserRole(s)
	default:
		return fmt.Errorf("unsupported scan type for UserRole: %T", src)
	}
	return nil
}

type NullUserRole struct {
	UserRole UserRole `json:"user_role"`
	Valid    bool     `json:"valid"` // Valid is true if UserRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserRole) Scan(value interface{}) error {
	if value == nil {
		ns.UserRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserRole), nil
}

type Customer struct {
	ID         pgtype.UUID        `json:"id"`
	LastName   string             `json:"last_name"`
	FirstName  string             `json:"first_name"`
	Username   string             `json:"username"`
	Email      pgtype.Text        `json:"email"`
	Password   string             `json:"password"`
	IsVerified pgtype.Bool        `json:"is_verified"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
}

type InvoiceInvoice struct {
	ID        pgtype.UUID              `json:"id"`
	TicketID  pgtype.UUID              `json:"ticket_id"`
	Amount    pgtype.Numeric           `json:"amount"`
	Currency  string                   `json:"currency"`
	Status    NullInvoiceInvoiceStatus `json:"status"`
	DueDate   pgtype.Date              `json:"due_date"`
	CreatedAt pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt pgtype.Timestamptz       `json:"updated_at"`
}

type InvoicePayment struct {
	ID          pgtype.UUID              `json:"id"`
	InvoiceID   pgtype.UUID              `json:"invoice_id"`
	Amount      pgtype.Numeric           `json:"amount"`
	PaymentDate pgtype.Timestamptz       `json:"payment_date"`
	Method      NullInvoicePaymentMethod `json:"method"`
	Status      NullInvoicePaymentStatus `json:"status"`
	CreatedAt   pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz       `json:"updated_at"`
}

type TenantTenant struct {
	ID         pgtype.UUID        `json:"id"`
	TenantName string             `json:"tenant_name"`
	Domain     string             `json:"domain"`
	Email      string             `json:"email"`
	IsActive   pgtype.Bool        `json:"is_active"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
}

type TenantTenantUser struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	UserID   pgtype.UUID `json:"user_id"`
}

type TicketComment struct {
	ID         pgtype.UUID        `json:"id"`
	TicketID   pgtype.UUID        `json:"ticket_id"`
	AuthorType string             `json:"author_type"`
	AuthorID   pgtype.UUID        `json:"author_id"`
	Comment    string             `json:"comment"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type TicketTicket struct {
	ID          pgtype.UUID        `json:"id"`
	TenantID    pgtype.UUID        `json:"tenant_id"`
	CustomerID  pgtype.UUID        `json:"customer_id"`
	AssignedTo  pgtype.UUID        `json:"assigned_to"`
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	Status      string             `json:"status"`
	Priority    string             `json:"priority"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ClosedAt    pgtype.Timestamptz `json:"closed_at"`
}

type User struct {
	ID         pgtype.UUID        `json:"id"`
	Username   string             `json:"username"`
	Email      string             `json:"email"`
	Password   string             `json:"password"`
	Role       UserRole           `json:"role"`
	IsActive   pgtype.Bool        `json:"is_active"`
	IsVerified pgtype.Bool        `json:"is_verified"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
	DeletedAt  pgtype.Timestamptz `json:"deleted_at"`
}
